# golang gc

经典的GC算法有三种： 引用计数(reference counting)、 标记-清扫(mark&sweep)、 复制收集(CopyandCollection)

## 标记-清扫(Mark And Sweep)算法

此算法主要有两个主要的步骤：

* 标记(Mark phase)

* 清除(Sweep phase)

第一步，找出不可达的对象，然后做上标记。
第二步，回收标记好的对象。


## 标记-清扫(Mark And Sweep)算法存在什么问题？
标记-清扫(Mark And Sweep)算法这种算法虽然非常的简单，但是还存在一些问题：

STW，stop the world；让程序暂停，程序出现卡顿。

标记需要扫描整个heap

清除数据会产生heap碎片

这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序。

## 三色并发标记法

首先：程序创建的对象都标记为白色。

gc开始：扫描所有可到达的对象，标记为灰色

从灰色对象中找到其引用对象标记为灰色，把灰色对象本身标记为黑色

监视对象中的内存修改，并持续上一步的操作，直到灰色标记的对象不存在

此时，gc回收白色对象。

最后，将所有黑色对象变为白色，并重复以上所有过程。

按照三色标记法的步骤，这样新生成的对象A最后会被清除掉，这样会影响程序逻辑。

Golang为了解决这个问题，引入了 `写屏障`这个机制。
写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。
通俗的讲：就是在gc跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。(实际上也是超短暂的stw，然后对对象进行标记)